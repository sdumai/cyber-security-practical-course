### SM3 软件实现与优化

#### 一、整体架构

国密算法 SM3 的哈希计算功能，包含以下核心模块：

1. 消息填充（sm3_pad）
2. 消息扩展（sm3_expand）
3. 压缩函数（sm3_compress）
4. 主哈希函数（sm3_hash）
5. 多种优化实现（循环展开/SIMD/预计算等）

#### 二、关键算法组件

1. **初始向量**：

   ```c
   0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600,
   0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E
   ```

2. **常量表 T**：

   - 前 16 轮使用 `0x79CC4519`
   - 后 48 轮使用 `0x7A879D8A`

3. **核心运算**：
   - 布尔函数：FF0/FF1/GG0/GG1
   - 置换函数：P0/P1
   - 循环左移：ROTL 宏

#### 三、优化策略详解

1. **循环展开优化**：

   - 将 64 轮压缩展开为 4 轮/次（实际应完整展开）
   - 减少循环控制开销
   - 示例：`sm3_compress_opt1()`

2. **预计算优化**：

   - 预先计算 `ROTL(T[j], j)` 值
   - 运行时直接查表避免重复计算
   - 实现：`init_T_rotl()` + `T_rotl[]`

3. **SIMD 并行化**：

   - 使用 AVX2 指令集（`__m256i` 类型）
   - 同时处理 4 个消息块（理论 4 倍吞吐量）
   - 关键函数：`sm3_compress_avx2()`

4. **内存访问优化**：

   - 合并消息扩展和压缩步骤
   - 减少中间数据存储（W/W1 数组）
   - 实现：`sm3_process_block()`

5. **分支消除**：

   ```c
   // 条件分支转换为算术运算
   #define FF(x, y, z, j) (((j) < 16) ? FF0(x,y,z) : FF1(x,y,z))

   // 替代方案：函数指针查表
   typedef uint32_t (*func_ptr)(uint32_t, uint32_t, uint32_t);
   static func_ptr FF_table[2] = {&FF0, &FF1};
   ```

#### 四、性能提升路径

| 优化阶段   | 关键技术            | 预期加速比 |
| ---------- | ------------------- | ---------- |
| 基础实现   | 标准算法实现        | 1.0x       |
| 编译优化   | -O3 优化选项        | 1.2x       |
| 循环展开   | 4× 循环展开         | 1.5x       |
| 预计算     | T_rotl 常量表       | 1.8x       |
| SIMD 指令  | AVX2 并行处理       | 4.0x       |
| 汇编级优化 | 内联汇编+寄存器分配 | 5.0x+      |

#### 五、关键函数说明

1. **消息填充 (sm3_pad)**：

   - 添加比特 1 + k 个 0 + 消息长度
   - 确保总长度是 512 位倍数

2. **消息扩展 (sm3_expand)**：

   ```mermaid
   graph LR
   A[512位分组] --> B[16×32位字]
   B --> C[扩展至68字W]
   C --> D[生成64字W1]
   ```

3. **压缩函数 (sm3_compress)**：
   - 64 轮迭代处理
   - 每轮更新 8 个状态变量
   - 核心操作：
     ```c
     SS1 = ROTL(A+E+T_rotl[j], 7)
     TT1 = FF(...) + D + SS2 + W1[j]
     TT2 = GG(...) + H + SS1 + W[j]
     ```

#### 六、使用示例

```c
// 计算哈希值
uint8_t digest[32];
sm3_hash((uint8_t*)"abc", 3, digest);

// 输出结果：66c7f0f4...b0fb0e4e
for(int i=0; i<32; i++) printf("%02x", digest[i]);
```
