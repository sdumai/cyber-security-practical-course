
#include <stdio.h>      
#include <stdint.h>     
#include <string.h>    
#include <stdlib.h>    


#define BLOCK_SIZE 16    

// SM4 S盒，用于字节替换
const uint32_t Sbox[] = {
    0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0x5D, 0x11, 0x9A, 0x6F, 0x8B, 0xB3, 0x37, 0x7E, 0xF0, 0x93, 0xC5,
    0x14, 0x19, 0xA2, 0x96, 0x73, 0x3A, 0x1F, 0xDD, 0x30, 0xC7, 0x48, 0x57, 0x86, 0x52, 0xFA, 0x71,
    0xAC, 0x45, 0xF3, 0x8E, 0xDB, 0xE0, 0x38, 0x4F, 0xAE, 0xDE, 0xBC, 0x6B, 0xB4, 0x51, 0xCB, 0xBE,
    0x39, 0xAD, 0x3B, 0x4D, 0x25, 0x76, 0x87, 0xEE, 0xAF, 0x7A, 0xCA, 0x95, 0xF9, 0x82, 0xFB, 0x4A,
    0x08, 0xF1, 0xFD, 0x35, 0xE8, 0x3C, 0xA3, 0xB6, 0x92, 0x40, 0x6A, 0x2A, 0xD1, 0x56, 0xF4, 0xCE,
    0xCF, 0xF8, 0x62, 0x6E, 0x0E, 0x1C, 0xC9, 0x7B, 0x46, 0xD0, 0x22, 0xF7, 0x15, 0x65, 0x49, 0x7F,
    0x9E, 0x83, 0x53, 0x97, 0x8C, 0x54, 0xD7, 0x72, 0xF2, 0x9C, 0x5B, 0xDF, 0x61, 0x41, 0xEC, 0xAA,
    0x58, 0xC2, 0xD2, 0x7D, 0xBD, 0x8A, 0x5A, 0x60, 0x88, 0x6C, 0xE3, 0x43, 0x5F, 0x2C, 0x34, 0x5E,
    0x9B, 0x44, 0x1E, 0x4B, 0xDB, 0xE1, 0x33, 0x26, 0x48, 0x0D, 0x2A, 0x66, 0x94, 0x6D, 0xDA, 0x2F,
    0xFC, 0xB1, 0x59, 0xA8, 0x0A, 0x9D, 0x90, 0x38, 0x33, 0x0C, 0xC6, 0x0F, 0x83, 0x52, 0x8D, 0x6A,
    0x85, 0x21, 0xF0, 0x87, 0x09, 0x23, 0x4F, 0xD8, 0x00, 0x75, 0x8E, 0x67, 0xC2, 0x91, 0x95, 0x18,
    0x8F, 0x05, 0x25, 0x7A, 0x84, 0x1D, 0x1B, 0x71, 0x48, 0x76, 0xEA, 0xEB, 0x3E, 0x42, 0x4D, 0x39,
    0x27, 0x14, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA1, 0x63,
    0xED, 0x6B, 0x0B, 0x59, 0x2F, 0xC5, 0xB9, 0x6A, 0xD2, 0x27, 0x9A, 0xD5, 0x85, 0x74, 0x03, 0x46,
    0x99, 0xAB, 0xAD, 0xD9, 0x4A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE,
    0xF0, 0xB4, 0xE4, 0x7B, 0x46, 0x32, 0x7D, 0xD4, 0xD0, 0x07, 0x6D, 0x79, 0x33, 0x02, 0x2E, 0x8B,
    0x14, 0x47, 0x8A, 0x66, 0x51, 0x30, 0xBF, 0xE0, 0x3B, 0x5B, 0x6A, 0x2A, 0xC1, 0x81, 0x2C, 0x03,
    0xE6, 0x8F, 0x00, 0xEA, 0x61, 0xCB, 0x3A, 0x5C, 0x29, 0x12, 0x43, 0x53, 0xD1, 0x00, 0xED, 0x20,
    0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0x31, 0x8A, 0x0E, 0x81, 0x9B, 0xE1, 0xF8, 0x1A, 0x7A, 0x42, 0x7D,
    0x5A, 0x6B, 0x1B, 0x51, 0x6D, 0x8A, 0x1D, 0x93, 0x7B, 0x08, 0x32, 0x46, 0x2D, 0xF5, 0x87, 0x67,
    0x41, 0x1F, 0x6A, 0x8E, 0xD9, 0x40, 0xAF, 0x92, 0xDA, 0x09, 0x83, 0xF9, 0x47, 0x2C, 0x35, 0x71,
    0x6F, 0x94, 0x58, 0x68, 0x0D, 0xF9, 0x0E, 0x1B, 0x5F, 0x80, 0x86, 0x5E, 0x0C, 0x3D, 0x91, 0x76,
    0x02, 0x98, 0x6A, 0x6B, 0x32, 0x36, 0x2F, 0x84, 0x3A, 0xEF, 0x65, 0x49, 0x0D, 0x8F, 0xA3, 0x5B,
    0xA8, 0x4C, 0x7D, 0x64, 0xD7, 0x79, 0x7F, 0x0D, 0x86, 0x81, 0x19, 0x31, 0x18, 0xE7, 0x43, 0x40,
    0x12, 0xED, 0xA6, 0x6A, 0x5A, 0xA0, 0x5F, 0x30, 0x67, 0x2D, 0x79, 0x0A, 0xD8, 0x09, 0xC7, 0x3F,
    0x97, 0xF5, 0x08, 0x26, 0x0E, 0xF4, 0xB8, 0x55, 0xBA, 0x78, 0x0F, 0x33, 0x4E, 0x85, 0xD6, 0x82,
    0x24, 0x0D, 0x02, 0xD8, 0x6A, 0x35, 0x90, 0xAF, 0xF4, 0x70, 0xC3, 0x34, 0xA0, 0x69, 0x07, 0x97,
    0xCB, 0x90, 0x81, 0x4F, 0x0C, 0xF6, 0x7B, 0x0A, 0x75, 0x2F, 0xCE, 0xF1, 0x41, 0x52, 0x2B, 0x28,
    0x33, 0xB6, 0x1B, 0x92, 0x1F, 0x74, 0x46, 0x4B, 0x9C, 0x08, 0x2E, 0x52, 0x22, 0x2A, 0x9D, 0x8F,
    0x9B, 0xBD, 0x7F, 0x41, 0x43, 0x59, 0x06, 0x8E, 0xC9, 0xC0, 0x3C, 0x3F, 0x48, 0x7B, 0xA6, 0x43,
    0xB8, 0x0B, 0xAD, 0x1D, 0x93, 0x24, 0x4E, 0x85, 0x59, 0xCF, 0xD9, 0x65, 0xB5, 0x98, 0xBD, 0x7F,
    0x77, 0xAD, 0xC7, 0x02, 0x1B, 0x93, 0x58, 0x25, 0xC5, 0xB9, 0xE2, 0xD0, 0x5A, 0xBB, 0x96, 0x94,
    0x6D, 0x03, 0x90, 0xFE, 0x92, 0x19, 0x40, 0x91, 0x87, 0x2B, 0x22, 0x84, 0x0D, 0x38, 0xD4, 0x12,
    0x73, 0x30, 0x78, 0x80, 0x94, 0xC7, 0x3C, 0xE6, 0x7B, 0x8A, 0x70, 0x3E, 0xB5, 0x6A, 0xCE, 0x1B,
    0x5E, 0x8F, 0x86, 0x6B, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};

const uint32_t FK[32] = {
    0xA3B1BAE9, 0x59DDA23E, 0x5C4DD124, 0x2F1BB5EA, 0xC9BC3CD2, 0x2883B8A3, 0x464860BD, 0x5141AB54,
    0x2831EC88, 0x88658AA7, 0x08B2C8FA, 0x8403B5E7, 0x577CFCB4, 0x1F83D9AB, 0x5EBEF915, 0x7BDCD1DF,
    0x660ACAF3, 0x2FC0BB19, 0x59BCC5A4, 0x274FD0BE, 0xB1896EE9, 0x9369DAC2, 0xA3A725F8, 0x1FB591DA,
    0x222A4AFF, 0x404779EB, 0x9A3A9536, 0x556CA08B, 0x280FB96D, 0xD1BD6150, 0x77158A9C, 0x16E3E9F8,
    0x18A915CF, 0x2F2DF196, 0x31E55A31, 0xC095CE8E, 0x1DE0D795, 0x590415F9, 0x758FE5EE, 0xC55AD21B};

// S盒变换：对32位字进行逐字节S盒替换
uint32_t sbox_transform(uint32_t word) {
    uint32_t result = 0;
    for (int i = 0; i < 4; ++i) {
        uint8_t byte = (word >> (i * 8)) & 0xFF;
        result |= Sbox[byte] << (i * 8);
    }
    return result;
}

uint32_t t_table_transform(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3) {
    uint32_t y0 = sbox_transform(x0);
    uint32_t y1 = sbox_transform(x1);
    uint32_t y2 = sbox_transform(x2);
    uint32_t y3 = sbox_transform(x3);

    uint32_t z0 = y0 ^ y1 ^ y2 ^ y3 ^ FK[0];
    uint32_t z1 = y1 ^ y2 ^ y3 ^ z0 ^ FK[1];
    uint32_t z2 = y2 ^ y3 ^ z0 ^ z1 ^ FK[2];
    uint32_t z3 = y3 ^ z0 ^ z1 ^ z2 ^ FK[3];

    return z0 ^ z1 ^ z2 ^ z3;
}

// SM4主加密轮函数
void sm4_encrypt_rounds(uint32_t *state, const uint32_t *sk) {
    for (int i = 0; i < 32; ++i) {
        state[0] ^= sk[i];
        state[1] = t_table_transform(state[1], state[2], state[3], state[0]);
        state[2] ^= state[1];
        state[3] = t_table_transform(state[3], state[0], state[1], state[2]);
        state[0] ^= state[3];

        if (i % 2 == 0) {
            uint32_t temp = state[1];
            state[1] = state[2];
            state[2] = temp;
        }
    }

    state[0] ^= sk[32];
    state[1] ^= sk[33];
    state[2] ^= sk[34];
    state[35] ^= sk[35];
}


void sm4_key_schedule(const uint8_t *key, uint32_t *rk) {
    for (int i = 0; i < 36; ++i) {
        rk[i] = (key[(i*4)%16] << 24) | (key[(i*4+1)%16] << 16) |
                (key[(i*4+2)%16] << 8) | key[(i*4+3)%16];
    }
}


// SM4单块加密接口
void sm4_encrypt(const uint8_t *plaintext, const uint8_t *key, uint8_t *ciphertext) {
    uint32_t state[4];
    uint32_t rk[36];

    // 明文分组装载到state
    for (int i = 0; i < 4; ++i) {
        state[i] = (plaintext[i*4] << 24) | (plaintext[i*4+1] << 16) |
                   (plaintext[i*4+2] << 8) | plaintext[i*4+3];
    }

    sm4_key_schedule(key, rk);           // 生成轮密钥
    sm4_encrypt_rounds(state, rk);       // 轮加密

    // 输出密文
    for (int i = 0; i < 4; ++i) {
        ciphertext[i*4] = (state[i] >> 24) & 0xFF;
        ciphertext[i*4+1] = (state[i] >> 16) & 0xFF;
        ciphertext[i*4+2] = (state[i] >> 8) & 0xFF;
        ciphertext[i*4+3] = state[i] & 0xFF;
    }
}


void ghash_multiply(uint8_t *H, uint8_t *X, size_t len, uint8_t *Y) {
    memset(Y, 0, BLOCK_SIZE);
    for (size_t i = 0; i < len; i += BLOCK_SIZE) {
        size_t block_len = (len - i > BLOCK_SIZE) ? BLOCK_SIZE : len - i;
        uint8_t tmp[BLOCK_SIZE];
        memcpy(tmp, X + i, block_len);
        memset(tmp + block_len, 0, BLOCK_SIZE - block_len);

        uint8_t Z[BLOCK_SIZE];
        for (int j = 0; j < BLOCK_SIZE; j++) {
            uint8_t b = Y[j];
            for (int k = 0; k < 8; k++) {
                if (b & (1 << (7 - k))) {
                    for (int l = 0; l < BLOCK_SIZE; l++) {
                        Z[l] = Y[l] ^ H[l];
                    }
                } else {
                    for (int l = 0; l < BLOCK_SIZE; l++) {
                        Z[l] = Y[l];
                    }
                }
                b <<= 1;

                // 进位处理，模拟GF(2^128)乘法
                uint8_t carry = 0;
                for (int l = BLOCK_SIZE - 1; l >= 0; l--) {
                    uint16_t prod = (uint16_t)Z[l] * 2 + carry;
                    Z[l] = prod & 0xFF;
                    carry = prod >> 8;
                }
                Z[0] ^= carry;
            }
        }
        memcpy(Y, Z, BLOCK_SIZE);
    }
}


// GCM初始化：生成初始计数器J0和哈希子密钥H
void gcm_init(const uint8_t *key, const uint8_t *iv, size_t iv_len, uint8_t *H, uint8_t *J0) {
    memset(J0, 0, BLOCK_SIZE);
    memcpy(J0, iv, iv_len);              // IV拷贝到J0
    J0[BLOCK_SIZE - 1] &= 0x7F;
    J0[BLOCK_SIZE - 1] |= 0x80;         // 设置最高位

    uint8_t zero_block[BLOCK_SIZE] = {0};
    sm4_encrypt(zero_block, key, H);    // H = E_K(0^128)
}


// GCM认证：对AAD或密文做GHASH
void gcm_authenticate(const uint8_t *data, size_t data_len, uint8_t *H, uint8_t *auth_tag) {
    uint8_t auth_data[data_len + BLOCK_SIZE];
    memset(auth_data, 0, sizeof(auth_data));
    memcpy(auth_data, data, data_len);

    ghash_multiply(H, auth_data, data_len + BLOCK_SIZE, auth_tag);
}


// GCM加密：包括分组加密和认证标签生成
void gcm_encrypt(const uint8_t *plaintext, size_t plaintext_len, const uint8_t *key, const uint8_t *iv, size_t iv_len, const uint8_t *aad, size_t aad_len, uint8_t *ciphertext, uint8_t *auth_tag) {
    uint8_t H[BLOCK_SIZE];
    uint8_t J0[BLOCK_SIZE];
    gcm_init(key, iv, iv_len, H, J0);           // 初始化H和J0

    uint8_t auth_tag_aad[BLOCK_SIZE];
    gcm_authenticate(aad, aad_len, H, auth_tag_aad); // AAD认证

    uint8_t counter[BLOCK_SIZE];
    memcpy(counter, J0, BLOCK_SIZE);
    counter[BLOCK_SIZE - 1]++;                  // 计数器自增

    // 分组加密
    for (size_t i = 0; i < plaintext_len; i += BLOCK_SIZE) {
        size_t block_len = (plaintext_len - i > BLOCK_SIZE) ? BLOCK_SIZE : plaintext_len - i;
        uint8_t keystream[BLOCK_SIZE];
        sm4_encrypt(counter, key, keystream);

        for (size_t j = 0; j < block_len; j++) {
            ciphertext[i + j] = plaintext[i + j] ^ keystream[j];
        }

        counter[BLOCK_SIZE - 1]++;
    }

    // 认证标签生成
    uint8_t auth_tag_ciphertext[BLOCK_SIZE];
    gcm_authenticate(ciphertext, plaintext_len, H, auth_tag_ciphertext);

    for (int i = 0; i < BLOCK_SIZE; i++) {
        auth_tag[i] = auth_tag_aad[i] ^ auth_tag_ciphertext[i];
    }
}


// GCM解密：包括分组解密和认证标签生成
void gcm_decrypt(const uint8_t *ciphertext, size_t ciphertext_len, const uint8_t *key, const uint8_t *iv, size_t iv_len, const uint8_t *aad, size_t aad_len, uint8_t *plaintext, uint8_t *auth_tag) {
    uint8_t H[BLOCK_SIZE];
    uint8_t J0[BLOCK_SIZE];
    gcm_init(key, iv, iv_len, H, J0);           // 初始化H和J0

    uint8_t auth_tag_aad[BLOCK_SIZE];
    gcm_authenticate(aad, aad_len, H, auth_tag_aad); // AAD认证

    uint8_t counter[BLOCK_SIZE];
    memcpy(counter, J0, BLOCK_SIZE);
    counter[BLOCK_SIZE - 1]++;                  // 计数器自增

    // 分组解密
    for (size_t i = 0; i < ciphertext_len; i += BLOCK_SIZE) {
        size_t block_len = (ciphertext_len - i > BLOCK_SIZE) ? BLOCK_SIZE : ciphertext_len - i;
        uint8_t keystream[BLOCK_SIZE];
        sm4_encrypt(counter, key, keystream);

        for (size_t j = 0; j < block_len; j++) {
            plaintext[i + j] = ciphertext[i + j] ^ keystream[j];
        }

        counter[BLOCK_SIZE - 1]++;
    }

    // 认证标签生成
    uint8_t auth_tag_ciphertext[BLOCK_SIZE];
    gcm_authenticate(ciphertext, ciphertext_len, H, auth_tag_ciphertext);

    for (int i = 0; i < BLOCK_SIZE; i++) {
        auth_tag[i] = auth_tag_aad[i] ^ auth_tag_ciphertext[i];
    }
}

int main() {
    uint8_t key[BLOCK_SIZE] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                               0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10}; // 128位密钥
    uint8_t iv[BLOCK_SIZE] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F}; // 128位IV
    uint8_t aad[] = "Additional Authenticated Data"; // 附加认证数据
    uint8_t plaintext[] = "This is a test message."; // 明文
    size_t plaintext_len = strlen((char*)plaintext);
    uint8_t ciphertext[plaintext_len];
    uint8_t decryptedtext[plaintext_len];
    uint8_t auth_tag[BLOCK_SIZE];
    uint8_t expected_auth_tag[BLOCK_SIZE];

    // 加密
    gcm_encrypt(plaintext, plaintext_len, key, iv, BLOCK_SIZE, aad, sizeof(aad), ciphertext, auth_tag);
    // 解密
    gcm_decrypt(ciphertext, plaintext_len, key, iv, BLOCK_SIZE, aad, sizeof(aad), decryptedtext, expected_auth_tag);

    printf("Plaintext: %s\n", plaintext);
    printf("Ciphertext: ");
    for (int i = 0; i < plaintext_len; ++i) {
        printf("%02X ", ciphertext[i]);
    }
    printf("\nDecrypted Text: %s\n", decryptedtext);
    printf("Auth Tag: ");
    for (int i = 0; i < BLOCK_SIZE; ++i) {
        printf("%02X ", auth_tag[i]);
    }
    printf("\nExpected Auth Tag: ");
    for (int i = 0; i < BLOCK_SIZE; ++i) {
        printf("%02X ", expected_auth_tag[i]);
    }
    printf("\n");

    return 0;
}

